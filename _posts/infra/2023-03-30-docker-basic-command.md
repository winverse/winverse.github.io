---
layout: post
author: winverse
title:  "[Docker] 기본 개념 정리 및 자주 사용하는 Command"
description: "왜 Docker를 사용해야하는지, Image와 Container의 개념을 이해하고 자주 사용하는 Command를 정리합니다."
tags: docker
category: infra
is_published: true
---

# 1. Why use the Docker?
## 1-1. 좋아지는 개발자의 경험
도커는 개발 및 배포를 단순화하는데 그 이유가 컨테이너를 사용하기 때문입니다. 컨테이너는 애플리케이션과 그 종속성을 함께 묶어서 실행 가능한 패키지로 만들어줍니다. 이렇게 하면 애플리케이션을 다양한 환경에서 일관되게 실행할 수 있습니다. 예를 들어, 개발자가 로컬 컴퓨터에서 작업한 애플리케이션을 테스트 서버 또는 프로덕션 서버로 배포할 때 종종 문제가 발생합니다. 이러한 문제는 서버의 운영 체제, 라이브러리 버전 등이 개발자의 로컬 컴퓨터와 다르기 때문입니다. 이 경우 도커를 사용하면 애플리케이션과 종속성을 함께 묶어서 컨테이너로 만들 수 있습니다. 그런 다음 이 컨테이너를 테스트 서버 또는 프로덕션 서버에서 실행할 수 있습니다. 이렇게 하면 애플리케이션이 일관되게 실행되므로 개발 및 배포가 단순화됩니다. 또 다른 예시로 서로 다른 환경에서 새로운 애플리케이션을 시작할 때 도움이 됩니다. IDE에서 애플리케이션을 설정하고 Windows 또는 Linux 기계에서 개발하는 것은 OS 또는 특정 OS 버전에서만 사용 가능한 특정 라이브러리와 같은 종속성 때문에 문제가 됩니다. 도커를 사용하면 이런 일이 필요 없습니다. 애플리케이션을 도커 이미지로 배송하고 팀원은 도커 이미지를 컨테이너로 실행하여 애플리케이션을 시작하고 디버그할 수 있습니다. 이렇게 하면 개발자의 경험이 좋아집니다.

## 1-2. VM 대비 성능
도커 컨테이너는 가상 머신보다 성능이 뛰어납니다. 가상 머신은 전체 OS를 로드해야 하기 때문에 도커 컨테이너보다 리소스가 더 많이 필요합니다. 도커 컨테이너의 경량 아키텍처는 가상 머신보다 리소스가 적게 필요합니다1. 이로 인해 도커 컨테이너는 거의 기본 성능을 제공합니다. 경량화되어 있기 때문에 몇 밀리초 안에 시작할 수 있습니다. 가상 머신을 시작하는 것은 컴퓨터 내부에 독립적인 기계를 설정하는 것과 같습니다. VM 인스턴스를 시작하는 데 몇 분 정도 걸릴 수 있습니다.

## 1-3. Docker를 사용하므로 달성하려는 목표
도커를 사용하면 개발자들이 애플리케이션을 더 쉽게 개발하고 배포할 수 있습니다. 이는 도커가 개발 및 배포를 단순화하기 때문입니다. 또한 도커는 팀원 간의 협업을 개선하는 데 도움이 됩니다. 모든 팀원이 동일한 소프트웨어 종속성 및 실행 환경으로 작업할 수 있도록 합니다. 이러한 이유로 많은 사람들이 도커를 사용합니다.


# 2. Image
도커의 두 가지 핵심 구성 요소 중 하나인 이미지는 컨테이너의 청사진/템플릿입니다. 이미지는 읽기 전용이며 애플리케이션과 필요한 애플리케이션 환경(운영 체제, 런타임, 도구 등)을 포함합니다. 이미지 자체는 실행되지 않고 대신 컨테이너로 실행될 수 있습니다. 이미지는 사전 빌드(예: DockerHub에서 찾을 수 있는 공식 이미지)되거나 Dockerfile을 정의하여 직접 빌드할 수 있습니다. Dockerfile에는 이미지가 빌드될 때( docker build . ) 실행되는 지시문이 포함되어 있으며 각 지시문은 이미지의 계층을 생성합니다. 계층은 이미지를 효율적으로 재구축하고 공유하는 데 사용됩니다. CMD 지시문은 특별합니다. 이미지가 빌드될 때가 아니라 해당 이미지를 기반으로 컨테이너가 생성되고 시작될 때 실행됩니다.

## 2-2. Image를 만드는 기반인 Dockerfile 예시 (Nodejs)
```dockerfile
FROM node:18

WORKDIR /app

# Build 최적화
COPY package.json .

RUN npm install

# Build 최적화
COPY . .

EXPOSE 80 # 문서화

CMD ["node", "app.js"]
```

### 2-2-1. COPY를 두번 실행하는 이유
첫 번째 COPY 명령어는 package.json 파일만 /app 디렉토리로 복사합니다. 그런 다음 RUN npm install 명령어를 사용하여 필요한 종속성을 설치합니다.

두 번째 COPY 명령어는 나머지 파일들을 모두 /app 디렉토리로 복사합니다.

이렇게 하는 이유는 도커가 이미지를 빌드할 때 캐시를 사용하기 때문입니다. 각 명령어가 실행될 때마다 도커는 새로운 레이어를 생성하고 캐시합니다. 이전에 빌드된 이미지와 동일한 명령어가 실행되면 도커는 캐시된 레이어를 재사용하여 빌드 시간을 단축합니다.

따라서 package.json 파일만 복사하고 종속성을 설치한 후 나머지 파일들을 복사하면, 소스 코드가 변경되더라도 package.json 파일이 변경되지 않으면 도커는 캐시된 레이어를 재사용하여 종속성 설치 과정을 건너뛸 수 있습니다. 이렇게 하면 이미지 빌드 시간이 크게 단축됩니다.

### 2-2-2. EXPOSE 명령어
EXPOSE는 Dockerfile의 명령어 중 하나로 컨테이너가 리스닝할 포트를 지정합니다. 이 명령어는 컨테이너가 실행될 때 호스트와 네트워크 연결을 설정하는 데 사용됩니다.

예를 들어 EXPOSE 80이라고 지정하면 컨테이너가 80번 포트에서 수신 대기하도록 지시합니다. 그러나 이 명령어는 단순히 문서화를 위한 것일 뿐이며 실제로 포트를 게시하지는 않습니다. 포트를 게시하려면 docker run 명령어에서 -p 플래그를 사용하여 호스트의 포트와 컨테이너의 포트를 매핑해야 합니다.

# Container
도커의 다른 핵심 구성 요소는 컨테이너입니다. 컨테이너는 이미지의 실행 인스턴스입니다. 컨테이너를 생성할 때(docker run을 통해) 이미지 위에 얇은 읽기/쓰기 레이어가 추가됩니다. 따라서 하나의 이미지를 기반으로 여러 개의 컨테이너를 시작할 수 있습니다. 모든 컨테이너는 격리되어 실행되므로 애플리케이션 상태나 작성된 데이터를 공유하지 않습니다. 컨테이너 내부의 애플리케이션을 시작하려면 컨테이너를 생성하고 시작해야 합니다. 따라서 개발 및 프로덕션에서 실행되는 것은 최종적으로 컨테이너입니다.

# Frequently used docker commands
- `docker build .` : Dockerfile을 빌드하고 파일을 기반으로 자신의 이미지를 만듭니다.
    - `-t NAME:TAG` : 이미지에 이름과 태그를 지정합니다.
- `docker run IMAGE_NAME` : 이미지 IMAGENAME(또는 이미지 ID 사용)을 기반으로 새 컨테이너를 생성하고 시작합니다.
    - `--name NAME` : 컨테이너에 이름을 지정합니다. 이름은 중지 및 제거 등에 사용할 수 있습니다.
    - `-d` : 컨테이너를 분리 모드로 실행합니다. 즉, 컨테이너가 출력하는 출력은 보이지 않으며 명령 프롬프트/터미널은 컨테이너가 중지될 때까지 대기하지 않습니다.
    - `-it` : 컨테이너를 "대화형" 모드로 실행합니다. 그러면 컨테이너/애플리케이션은 명령 프롬프트/터미널을 통해 입력을 받을 준비가 됩니다. -it 플래그를 사용하면 CMD + C로 컨테이너를 중지할 수 있습니다.
    - `--rm` : 컨테이너가 중지될 때 자동으로 제거합니다.
- `docker ps` : 실행 중인 모든 컨테이너를 나열합니다.
    - `-a` : 중지된 컨테이너를 포함한 모든 컨테이너를 나열합니다.
- `docker images` : 로컬에 저장된 모든 이미지를 나열합니다.
- `docker rm CONTAINER` : 이름이 CONTAINER인 컨테이너를 제거합니다(컨테이너 ID도 사용할 수 있음).
- `docker rmi IMAGE` : 이름/ID로 이미지를 제거합니다.
- `docker container prune` : 모든 중지된 컨테이너를 제거합니다.
- `docker image prune` : 모든 dangling 이미지(태그가 없는 이미지)를 제거합니다.
    - `-a` : 로컬에 저장된 모든 이미지를 제거합니다.
- `docker push IMAGE` : DockerHub(또는 다른 레지스트리)에 이미지를 푸시합니다. 이미지 이름/태그는 저장소 이름/URL을 포함해야 합니다.
- `docker pull IMAGE` : DockerHub(또는 다른 레지스트리)에서 이미지를 가져옵니다(pull). 이 작업은 docker run IMAGE를 실행할 때 이미지가 이전에 가져오지 않은 경우 자동으로 수행됩니다.