---
layout: post
author: winverse
title:  "Software architecture에 대해서"
description: 이번 글을 통해서 Hexagonal architecture에 대해서 알아보며 기존에 어떤 문제점이 있었는지 그리고 어떤 문제를 해결하였는지 왜 Hexagonal architecture가 필요한지에 대해서 알아보겠습니다.
tags: Architecture Layerd-architecture Hexagonal-architecture Clean-architecture 
category: architecture
is_published: false
---

`이 글은 헥사고날 아키텍쳐에 관해서 알아보며 정리한 글 입니다.`

# 아키텍쳐란 (Feat: IEEE)
> 구성요들간의 관계, 환경, 설계와 발전을 관리하는 원칙으로 이루어진 시스템의 근본적인 구조 (by IEEE)

하지만 이런 정의는 너무 포괄적인 컴포넌트라는 단점이 있습니다. 그래서 이 글에서는 아키텍쳐란 위 내용보다는 단순하게 소프트웨어를 구성하고 있는 부품들 간의 연결 관계정도로 생각하고 글을 적도록 하겠습니다.

# 1.아키텍쳐의 목표
아키텍쳐의 목표를 알아야지 우리는 더 좋은 아키텍쳐의 대해서 탐구해보며 이것이 왜 좋은 아키텍쳐인지 알 수가 있습니다. 그래서 먼저 아키텍쳐의 목표에 대해서 이야기 해볼까 합니다. 소프트웨어를 정의하는 여러 문장 중에 `다양한 문제를 해결하기 위한 프로그램`이라는 정의가 있는데요. 아키텍쳐를 통해서 얻고자 하는 것은 다양한 문제를 해결하기 위한 프로그램을 만드는 것이라고 생각해볼 수 있으며 `프로그램을 만들기 위해서 어떻게 구성요소를 연결하고 프로그램의 품질을 높일까?`에 대한 고민이 아키텍쳐의 목표라고 생각해볼 수 있습니다. 그러면 이런 생각을 가지고서 더욱 자세하게 아키텍쳐의 목표에 대해서 알아볼까요?

## 1-1. 비즈니스 로직과 기술적인 측면의 분리
소프트웨어를 관리하다보면 다양한 비즈니스적 변화에 대응 해야할 때가 많습니다. 심지어 `그때는 맞고 지금은 틀리다`와 같은 상황이 생길지도 모르지요. 그렇기 때문에 유기적으로 변하는 외부 비즈니스 로직에 대응하는 것이 쉬우려면 우리가 작성하는 코드(도메인 부분)가 외부 비즈니스에 대한 의존성이 낮아야지 새로운 변화에 대응하기 쉽습니다. 이렇게 도메인과 외부 세부 사항 변경을 철저하게 분리하여 보호하게 되면 유지보수 측면에서 이점이 있습니다. 이를 통해서 프로그래머는 더욱 더 도메인 부분인 핵심 비즈니스 로직에 집중할 수 가 있고 이를 통해서, 고객에게 `핵심 가치`를 전달하는데 훨씬 용이할 것 입니다.

## 1-2. 확장성과 유지보수성
이런 관심사의 분리는 코드의 분리로 이어지며, 분리된 코드는 모듈의 확장/변경에 용이해지고 이를 통해서 더 많은 기능을 추가/삭제하여도 구조는 유지가 되어 소프트웨어를 지속적으로 운용 가능하도록 합니다.

## 1-3. 쉬워지는 테스트
현대 시대에서 큰 소프트웨어를 운용하는데 있어서 정확성과 안정성을 가져다주는 테스트 코드는 빠질 수 없는 부분입니다. 아키텍쳐를 통해서 관심사를 분리하고 여러 부분들을 알맞게 나누어서 모듈화 된 부분들은 각 부분 테스트에만 신경쓰면 되기 때문에 테스트에 용이해지는 장점이 있습니다.

## 1-5. 좋은 아키텍쳐를 도입해야하는 이유
좋은 아키텍쳐를 도입한다는 것은 위의 장점을 가져간다는 것들이 오랜 기간 소프트웨어를 운용하는데 있어서 꼭 필요한 요소들이므로 우리는 좋은 아키텍쳐를 만들기 위해서 상당히 오랜 공을 들여야 한다는 사실을 알 수 있습니다. 

# 2.Layered Architecture (계층형 아키텍쳐)
{% highlight markdown %}
+-----------------------------+
|         Web Layer           |
+-----------------------------+
|         Domain Layer        |
+-----------------------------+
|       Persistence Layer     |
+-----------------------------+
# 전통적인 Layered Architecture
{% endhighlight markdown %}  
전통적인 Layered Architecture은 목적이 같은 코드들을 같은 계층으로 그룹화 시켜서 분리하는 것을 의미 합니다. 예를 들어 프레젠테이션 계층(Ui 같은), 도메인 계층(중요 비즈니스 로직), 영속성 계층으로 나누어 볼 수 있습니다. 이렇게 나누어진 잘 나누어진 Layer는 다른 Layer층에 기능적 영향을 주는 것 없이 새로운 기능을 추가할 수 있다는 장점과 문제가 생기면 어느 부분에서 문제가 생기는지 알 수 있는 장점이 있습니다. 이를 통해서 `핵심 가치`를 고객에게 전달 할 수 있습니다.

## Layered Architecture의 한계

# 3.Clean Architecture

# 4.Hexagonal architecture

# 5.디자인 스태미너 가설 (feat: martin )

# 참고
1. [https://blog.jiniworld.me/176](https://blog.jiniworld.me/176)
2. [코드로 이해하기 헥사고날 아키텍트](https://happy-coding-day.tistory.com/entry/%ED%97%A5%EC%82%AC%EA%B3%A0%EB%82%A0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98Hexagonal-Architecture-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EA%B8%B0-%EB%AF%B8%EC%99%84%EC%84%B1)
3. [기획자님들! 개발자가 아키텍처에 집착하는 이유, 쉽게 알려드립니다](https://youtu.be/saxHxoUeeSw)
4. [클린아키텍처는 죽었다! 헥사고날 아키텍처 10분만에 대충 이해시켜 드림](https://youtu.be/MKfSLrwLex8)